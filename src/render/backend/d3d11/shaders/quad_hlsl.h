char quad_hlsl[] = 
"#line " Stringify(__LINE__) " \n\n"
"struct VS_Input\n"
"{\n"
"  float4 rect            : RECT;\n"
"  float4 uv_rect         : UV_RECT;\n"
"  float4 c0              : CL;\n"
"  float4 c1              : CR;\n"
"  float4 c2              : CB;\n"
"  float4 c3              : CT;\n"
"  float theta            : THETA;\n"
"  float radius           : RADIUS;\n"
"  uint sample_mode       : SAMPLE_MODE;\n"
"  float border_thickness : BORDER_THICKNESS;\n"
"  float corner_softness  : CORNER_SOFTNESS;\n"
"  float4 clip_rect       : CLIP_RECT;\n"
"};\n"
"\n"
"struct PS_Input\n"
"{\n"
"  float4 uv_rect         : TEXCOORD0;\n"
"  float4 c0              : COLOR0;\n"
"  float4 c1              : COLOR1;\n"
"  float4 c2              : COLOR2;\n"
"  float4 c3              : COLOR3;\n"
"  float radius           : PSIZE0;\n"
"  float sample_mode      : PSIZE1;\n"
"  float border_thickness : PSIZE2;\n"
"  float corner_softness  : PSIZE3;\n"
"  float4 clip_rect       : TEXCOORD1;\n"
"  float2 rect_center     : POSITION0;\n"
"  float2 rect_half_dim   : POSITION1;\n"
"  float2 pos             : POSITION2;\n"
"  float theta            : PSIZE4;\n"
"  float4 position        : SV_Position;\n"
"};\n"

"float sdf_rounded_rect(float2 pos, float2 rect_center, float2 rect_half_size, float r)\n"
"{\n"
"  float2 d2 = abs(rect_center - pos) - rect_half_size + float2(r,r);\n"
"  float dist = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0)) - r;\n"
"  return dist;\n"
"}\n"

"sampler sampler0 : register(s0);\n"
"Texture2D<float4> texture0 : register(t0);\n"

"PS_Input vs_main(VS_Input input, uint vertex_id : SV_VertexID)\n"
"{\n"
// Constants
"  static float2 vertices[6] = {\n"
"    {-1.f, +1.f}, {+1.f, +1.f}, {-1.f, -1.f},\n"
"    {+1.f, +1.f}, {+1.f, -1.f}, {-1.f, -1.f},\n"
"  };\n"
"  static float2 res = float2(1280, 680);\n"
// Get this vertex's screen-space point
"  float2 v = vertices[vertex_id];\n"
"  float4 rect = input.rect;\n"
"  rect.y = -rect.y + res.y;\n"
"  rect.w = -rect.w + res.y;\n"
"  float2 center = (rect.xy + rect.zw) * 0.5;\n"
"  float2 half_dim = (rect.zy - rect.xw) * 0.5;\n"
"  float2 q = center + half_dim * v;\n"
// Clamp to exact pixel coordinates
// TODO: Clamp qr instead?
"  if (v.x < 0.0) q.x = floor(q.x);\n"
"  else           q.x = ceil(q.x); \n"
"  if (v.y < 0.0) q.y = floor(q.y);\n"
"  else           q.y = ceil(q.y); \n"
// Rotate screen-space point
"  float2 qr = q - center;\n"
"  float s = sin(input.theta);\n"
"  float c = cos(input.theta);\n"
"  float2 pr = float2(c*qr.x-s*qr.y,s*qr.x+c*qr.y);\n" 
// Compute vertex shader outputs
"  float2 p = center + pr;\n"
"  float2 clip_p = float2(\n"
"    2.0 * p.x / res.x - 1.0,\n"
"    2.0 * p.y / res.y - 1.0\n"
"  );\n"

"  PS_Input output;\n"
"  output.position = float4(clip_p.x,clip_p.y,0.0,1.0);\n"
"  output.uv_rect = input.uv_rect;\n"
"  output.c0 = input.c0;\n"
"  output.c1 = input.c1;\n"
"  output.c2 = input.c2;\n"
"  output.c3 = input.c3;\n"
"  output.radius = input.radius;\n"
"  output.sample_mode = (float)input.sample_mode;\n"
"  output.border_thickness = input.border_thickness;\n"
"  output.corner_softness = input.corner_softness;\n"
"  output.clip_rect = input.clip_rect;\n"
"  output.rect_center = center;\n"
"  output.rect_half_dim = half_dim;\n"
"  output.pos = q;\n"
"  output.theta = input.theta;\n"
"  return output;\n"
"}\n"
"\n"
"#define R_SAMPLE_MODE_COLOR 0.0\n"
"#define R_SAMPLE_MODE_ALPHA 1.0\n"
"float4 ps_main(PS_Input input) : SV_TARGET\n"
"{\n"
"  float4 cl = input.clip_rect;\n"
"  if (cl.x && cl.y && cl.z && cl.w) {\n"
"    if ((input.position.x <  cl.x) ||\n"
"        (input.position.y <  cl.y) ||\n"
"        (input.position.x >= cl.z) ||\n"
"        (input.position.y >= cl.w)) {\n"
"      discard;\n"
"    }\n"
"  }\n"
// Rotation (opposite of rect's rotation)
// TODO: You could just give the fs the rotated position, right?
"  float2 q = input.pos - input.rect_center;\n"
"  float c = cos(-input.theta);\n"
"  float s = sin(-input.theta);\n"
"  q = float2(c*q.x-s*q.y,s*q.x+c*q.y);\n" 
// Get this fragment's position within current quad ([-1, 1] in x, y)
"  float uv_xtu = (q.x + input.rect_half_dim.x)/(2.0*input.rect_half_dim.x);\n"
"  float uv_ytu = (q.y + input.rect_half_dim.y)/(2.0*input.rect_half_dim.y);\n"
// Get UV coords for this fragment from the current quad's UV rect ([0, 1] in x, y)
"  float4 color = float4(1.0,1.0,1.0,1.0);\n"
// TODO: Upload sample mode as uint, convert in vs
"  if (input.uv_rect.z > 0.0) {\n"
"    int2 tex_size;\n"
"    texture0.GetDimensions(tex_size.x, tex_size.y);\n"
"    float2 htex = float2(0.5/tex_size.x, 0.5/tex_size.y);\n"
"    float uv_xu = input.uv_rect.x + (input.uv_rect.z-input.uv_rect.x) * uv_xtu;\n"
"    float uv_yu = input.uv_rect.y + (input.uv_rect.w-input.uv_rect.y) * uv_ytu;\n"
"    float uv_x = clamp(uv_xu, input.uv_rect.x+htex.x, input.uv_rect.z-htex.x);\n"
"    float uv_y = clamp(uv_yu, input.uv_rect.y+htex.y, input.uv_rect.w-htex.y);\n"
"    float2 uv = float2(uv_x, uv_y);\n"
// Sample from the texture according to the quad's sample mode
"    if (input.sample_mode == R_SAMPLE_MODE_COLOR) {\n"
"      color = texture0.Sample(sampler0, uv);\n"
"    }\n"
"    else if (input.sample_mode == R_SAMPLE_MODE_ALPHA) {\n"
"      float s = texture0.Sample(sampler0, uv).r;\n"
"      color.a *= s;\n"
"    }\n"
"  }\n"
// Calculate color gradient interpolation factors 
"  float color_v_t = clamp(uv_ytu, 0.0, 1.0);\n"
"  float color_h_t = clamp(uv_xtu, 0.0, 1.0);\n"
// Shrink the rectangle's half-size used for distance calculations with the edge 
// softness. If we don't do this, the underlying primitive will cut off the falloff 
// too early (https://www.rfleury.com/p/ui-part-6-rendering).
"  float softness = input.corner_softness;\n"
"  float soft_n = softness*2.0-1.0;\n"
"  float2 softness_padding = float2(max(0, soft_n), max(0, soft_n));\n"
// Compute filled/hollow rounded rectangle SDF factors
"  float d0 = sdf_rounded_rect(input.pos, input.rect_center,\n"
"    input.rect_half_dim-softness_padding, input.radius);\n"
"  float d1 = sdf_rounded_rect(input.pos, input.rect_center, input.rect_half_dim-\n"
"    input.border_thickness-softness_padding, input.radius-input.border_thickness);\n"
"  float sdf_factor = 1.0 - smoothstep(0.0, 2.0*softness, d0);\n"
"  float border_factor = smoothstep(0.0, 2.0*softness, d1);\n"
// Don't consider SDF factor for alpha sampling mode
"  sdf_factor = lerp(sdf_factor, 1.0, input.sample_mode);\n"
// Compute final fragment color 
"  float4 gradient_color = lerp(input.c0,input.c1,color_h_t) * lerp(input.c2,input.c3,color_v_t);\n"
"  float4 fill_color = lerp(color, float4(border_factor,border_factor,border_factor,border_factor), input.border_thickness);\n"
"  return fill_color * gradient_color * sdf_factor;\n"
"}\n";
